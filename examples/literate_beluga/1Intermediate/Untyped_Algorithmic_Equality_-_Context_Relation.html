<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<!--<link rel="icon" href="/beluga-site/favicon.png" />-->
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		
		<link href="/beluga-site/_app/immutable/assets/0.ZN52t8Dy.css" rel="stylesheet">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/entry/start.g-2aDSD5.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/chunks/entry.l65HBOEx.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/chunks/scheduler.BRW4IjsR.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/chunks/paths.I5prkiXN.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/entry/app.4pCwBffu.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/chunks/index.yRNBcVz4.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/nodes/0.yLnkYr-I.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/chunks/each.6w4Ej4nR.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/chunks/stores.5r-2jwDb.js">
		<link rel="modulepreload" href="/beluga-site/_app/immutable/nodes/12.0TJqB1GB.js"><title>Algorithmic Equality for the Untyped Lambda-calculus (R-version)</title><!-- HEAD_svelte-pcdrka_START --><!-- HEAD_svelte-pcdrka_END -->
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">  <nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container"><a class="navbar-brand" href="/beluga-site/" data-svelte-h="svelte-jlhy6h">Beluga</a> <button class="navbar-toggler" type="button" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button> <div class="collapse navbar-collapse collapse" id="navbarSupportedContent"><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item"><a class="nav-link " href="/beluga-site/">Home</a> </li><li class="nav-item"><a class="nav-link " href="/beluga-site/#installation">Install</a> </li><li class="nav-item"><a class="nav-link " href="/beluga-site/documentation">Documentation</a> </li><li class="nav-item"><a class="nav-link " href="/beluga-site/casestudies">Case Studies</a> </li><li class="nav-item"><a class="nav-link " href="/beluga-site/people">People</a> </li><li class="nav-item"><a class="nav-link " href="/beluga-site/downloads">Downloads</a> </li></ul></div></div></nav> <div class="container mt-4"> <!-- HTML_TAG_START --><div class="documentation">
	<h1 id="Algorithmic-Equality-for-the-Untyped-Lambda-calculus-(R-version)">
		Algorithmic Equality for the Untyped Lambda-calculus (R-version)
	</h1>
	<p>
		We discuss completeness of algorithmic equality for untyped lambda-terms with respect to
		declarative equality of lambda-terms. This case-study is part of
		<a href="https://github.com/pientka/ORBI">ORBI</a>, Open challenge problem Repository for
		systems reasoning with Binders. For a detailed description of the proof and a discussion
		regarding other systems see
		<a target="_blank" href="/beluga-site/orbi-jar.pdf">(Felty et al, 2014)</a>.
	</p>
	<p>The mechanization highlights several aspects:</p>
	<ul>
		<li>Induction on universally quantified objects</li>
		<li>First-class substitution variables</li>
		<li>Context weakening and strengthening with inductive inductives</li>
	</ul>

	<h3 id="Syntax">Syntax</h3>

	<p>
		Untyped lambda-terms are introduced with LF-level declarations. The context schemas translate
		directly from the ORBI file.
	</p>
</div>

<pre><code><span class="keyword keyword-LF">LF</span> <span id="lf-type-tm" class="constant lf-type-constant">tm</span> : <span class="keyword keyword-type">type</span> =
| <span id="lf-term-app" class="constant lf-term-constant">app</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>
| <span id="lf-term-lam" class="constant lf-term-constant">lam</span> : (<span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>;

<span class="keyword keyword-LF">LF</span> <span id="lf-type-aeq" class="constant lf-type-constant">aeq</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> → <span class="keyword keyword-type">type</span> =
| <span id="lf-term-ae_l" class="constant lf-term-constant">ae_l</span> :
  ({x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>} <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span> → <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> (<span class="variable lf-variable">M</span> <span class="variable lf-variable">x</span>) (<span class="variable lf-variable">N</span> <span class="variable lf-variable">x</span>)) → <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable lf-variable">M</span> <span class="variable lf-variable">x</span>)) (<span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable lf-variable">N</span> <span class="variable lf-variable">x</span>))
| <span id="lf-term-ae_a" class="constant lf-term-constant">ae_a</span> : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">M1</span> <span class="variable lf-variable">N1</span> → <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">M2</span> <span class="variable lf-variable">N2</span> → <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable lf-variable">M1</span> <span class="variable lf-variable">M2</span>) (<span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable lf-variable">N1</span> <span class="variable lf-variable">N2</span>);

<span class="keyword keyword-schema">schema</span> <span id="schema-xG" class="constant context-schema">xG</span> = <span class="keyword keyword-block">block</span> <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>;

<span class="keyword keyword-schema">schema</span> <span id="schema-xaG" class="constant context-schema">xaG</span> = <span class="keyword keyword-block">block</span> (<span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, <span class="variable lf-variable">u</span> : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>);</code></pre>

<div class="documentation">
	<h2 id="Context-Relationships-via-Inductive-Datatypes">
		Context Relationships via Inductive Datatypes
	</h2>

	<p>
		The key to express context weakening and strengthening is the ability to relate two contexts via
		a substitution. In Beluga, we can describe context relations using
		<em>inductive inductives</em> as a relation between context <code>φ</code>, context
		<code>ψ</code>, and a substitution <code>$σ</code> that maps variables from <code>φ</code> to
		the context <code>ψ</code>, formally <code>$σ : $[ψ |- φ]</code> as follows:
	</p>
</div>

<pre><code><span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-Ctx_xaR" class="constant computation-inductive-type-constant">Ctx_xaR</span> : {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xaG">xaG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">ψ</span> ⊢ <span class="variable context-variable">φ</span>)} <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-Nil_xa" class="constant computation-constructor">Nil_xa</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [] [] $[ ⊢ ]
| <span id="comp-const-Cons_xa" class="constant computation-constructor">Cons_xa</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
      $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> ⊢ <span class="variable substitution-variable">$σ</span>[…], <span class="variable lf-variable">b</span>.1];</code></pre>

<div class="documentation">
	<p>
		The first-class substitution variable <code>$σ</code> has domain <code>φ</code> and range
		<code>ψ</code>. If <code>$σ</code> relates contexts <code>φ</code> and <code>ψ</code>, then the
		substitution <code>$σ, b.1</code> relates <code>φ, x:tm</code> to
		<code>ψ, b:block (x:tm, u:aeq x x)</code> via constructor <code>Cons_xaR</code>.
	</p>
</div>

<pre><code><span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-EqV" class="constant computation-inductive-type-constant">EqV</span> :
  {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xaG">xaG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">ψ</span> ⊢ <span class="variable context-variable">φ</span>)} (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-EqV_v" class="constant computation-constructor">EqV_v</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
    $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable substitution-variable">$σ</span>, <span class="variable lf-variable">b</span>.1] [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable lf-variable">x</span>]
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable lf-variable">b</span>.1]
| <span id="comp-const-EqV_p" class="constant computation-constructor">EqV_p</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)] $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> ⊢ <span class="variable substitution-variable">$σ</span>[…], <span class="variable lf-variable">b</span>.1]
      [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable parameter-variable">#p</span>[…]] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable parameter-variable">#q</span>.1[…]];

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-Eq" class="constant computation-inductive-type-constant">Eq</span> :
  {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xaG">xaG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">ψ</span> ⊢ <span class="variable context-variable">φ</span>)} (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-Eq_v" class="constant computation-constructor">Eq_v</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1]
| <span id="comp-const-Eq_a" class="constant computation-constructor">Eq_a</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M'</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N'</span>] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M</span> <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M'</span> <span class="variable meta-variable">N'</span>]
| <span id="comp-const-Eq_l" class="constant computation-constructor">Eq_l</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
    $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable substitution-variable">$σ</span>[…], <span class="variable lf-variable">b</span>.1] [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable meta-variable">M</span>]
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">M'</span>[…, <span class="variable lf-variable">b</span>.1]] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M</span>)] [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M'</span>)];</code></pre>

<div class="documentation">
	<h3 id="Proof-of-Reflexivity-Compact-version">Proof of Reflexivity, Compact version</h3>

	<p>
		The recursive function <code>refl</code> of type
		<code>{φ:xG} {M: [φ |- tm]} Ctx_xaR [φ] [ψ] [ψ |- $σ] -&gt; [ψ |- aeq M[$σ] M[$σ]]</code>: for
		all contexts <code>φ</code> and <code>ψ</code> that have schema <code>xG</code> and
		<code>xaG</code>, respectively, if we have a substitution <code>$σ</code> s.t.
		<code>$σ : [ψ |- φ]</code> then for all terms <code>M</code> depending on <code>φ</code>, we
		have a proof that <code>[ψ |- aeq #p[$σ] #p[$σ]]</code>. Since the term <code>M</code> depends
		only on the context <code>φ</code>, it is explicitly weakened through applying
		<code>$σ</code> to move it to the context <code>ψ</code>.
	</p>
</div>

<pre><code><span class="keyword keyword-rec">rec</span> <span id="theorem-ctx_membership" class="constant computation-program">ctx_membership</span> :
  {<span class="variable meta-variable">#p</span> : #(<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)} <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable parameter-variable">#p</span>[<span class="variable substitution-variable">$σ</span>] <span class="variable parameter-variable">#p</span>[<span class="variable substitution-variable">$σ</span>]) =
<span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">#p</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr</span> ⇒ <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable lf-variable">x</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'</span> = <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr'</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr'</span> <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable lf-variable">b</span>.2]
  | [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable parameter-variable">#p</span>[…]] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'</span> = <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E</span>] = <span class="constant computation-program"><a href="#theorem-ctx_membership">ctx_membership</a></span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="variable computation-variable">cr'</span> <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">E</span>[…]];

<span class="keyword keyword-rec">rec</span> <span id="theorem-refl" class="constant computation-program">refl</span> :
  {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">M</span> : (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)} <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable meta-variable">M</span>[<span class="variable substitution-variable">$σ</span>] <span class="variable meta-variable">M</span>[<span class="variable substitution-variable">$σ</span>]) =
<span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">φ</span> ⇒ <span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">M</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr</span> ⇒
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] ⇒ <span class="constant computation-program"><a href="#theorem-ctx_membership">ctx_membership</a></span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="variable computation-variable">cr</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M</span> <span class="variable meta-variable">N</span>] ⇒ <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">D1</span>] = <span class="constant computation-program"><a href="#theorem-refl">refl</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">D2</span>] = <span class="constant computation-program"><a href="#theorem-refl">refl</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">N</span>] <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_a">ae_a</a></span> <span class="variable meta-variable">D1</span> <span class="variable meta-variable">D2</span>]
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M</span>)] ⇒
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">D</span>[…, <span class="variable lf-variable">b</span>.1, <span class="variable lf-variable">b</span>.2]] =
      <span class="constant computation-program"><a href="#theorem-refl">refl</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable meta-variable">M</span>] (<span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr</span>) <span class="keyword keyword-in">in</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_l">ae_l</a></span> (\x. \u. <span class="variable meta-variable">D</span>)];</code></pre>

<div class="documentation">
	<p>
		In the application case, we appeal to the induction hypothesis on
		<code>[φ |- M]</code> and <code>[ |- N]</code> through a recursive call. Since the context
		<code>φ</code> and the context <code>ψ</code> do not change, we can simply make the recursive
		all on <code>[φ |- M]</code> and <code>[φ |- M]</code> respectively using the relation
		<code>cr</code>.
	</p>
	<p>
		When we have <code>[φ |- lam \x.M]</code>, we want to appeal to the induction hypothesis on
		<code>[φ, x:tm |- M]</code>. In this instance, we also need a witness relating the context
		<code>[φ, x:tm |- M]</code> to the context <code>[ψ, b:block (x:tm, u:aeq x x)]</code>. Recall
		that <code>cr</code> stands for <code>Ctx_xaR [φ] [ψ] $[ψ |- $σ]</code>. Therefore, by
		<code>Cons_xa</code>, we know there exists
		<code>Ctx_xaR [φ , x:tm] [ψ , b:block (x:tm, u:aeq x x)] $[ψ, b |- $σ, b.1]</code>
		and we appeal to the induction hypothesis by
		<code>reflR [φ, x:tm] [φ, x:tm.M] (Cons_xa cr)</code>.
	</p>
	<p>
		Finally, we take a close look at the variable case. We distinguish two different cases depending
		on the position of the variable in the context by pattern matching on the shape of
		<code>φ</code>. If <code>[φ, x:tm |- x]</code>, then we inspect the context relation
		<code>cr</code>. Pattern matching forces the original context <code>φ</code> to be
		<code>φ, x:tm</code>. By pattern matching on <code>cr'</code>, we observe that there exists a
		relation <code>cr'</code>, s.t. <code>Ctx_xaR [φ] [ψ] $[ψ |- $σ]</code>. Moreover,
		<code>ψ = ψ, b:block (x:tm, u:aeq x x)</code> and <code>$σ = $σ, b.1</code> where the left hand
		side denotes the original context and substitution, while the right hand side shows the context
		and substitution refinement after pattern matching. We must show that there exists a proof for
		<code>aeq x x</code> in the context <code>ψ, b:block (x:tm, u:aeq x x)</code>. This is simply
		<code>b.2</code>.
	</p>

	<p>
		Following we generalize reasoning about terms which contain substitution variables, reasoning
		explicitly about equality between terms
		<code>M</code> and <code>M[$σ]</code>. Since we cannot pattern match directly on
		<code>M[$σ]</code> (because <code>$σ</code> is a general substitution and we do not enforce on
		the type-level that it is a variable-variable substitution) we cannot use unification to solve
		equations; If <code>$σ</code> would be known to be a pattern substitution, then we could solve
		equations such as <code>M[$σ] = app M1 M2</code>; we hence encode such equalities explicitly.
	</p>
	<h3 id="Proof-of-Reflexivity-Expanded">Proof of Reflexivity, Expanded</h3>
</div>

<pre><code><span class="keyword keyword-rec">rec</span> <span id="theorem-ctx_member" class="constant computation-program">ctx_member</span> :
  {<span class="variable meta-variable">#p</span> : #(<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)}
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M</span>] → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable meta-variable">M</span> <span class="variable meta-variable">M</span>) =
<span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">#p</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m</span> ⇒ <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable lf-variable">x</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'</span> = <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_v">EqV_v</a></span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr'</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr'</span> <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable lf-variable">b</span>.2]
  | [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable parameter-variable">#p</span>[…]] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'</span> = <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_p">EqV_p</a></span> <span class="variable computation-variable">m'</span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E</span>] = <span class="constant computation-program"><a href="#theorem-ctx_member">ctx_member</a></span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="variable computation-variable">cr'</span> <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">E</span>[…]];

<span class="keyword keyword-rec">rec</span> <span id="theorem-reflR" class="constant computation-program">reflR</span> :
  {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>}
    {<span class="variable meta-variable">M</span> : (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)}
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
        <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M'</span>] → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable meta-variable">M'</span> <span class="variable meta-variable">M'</span>) =
<span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">φ</span> ⇒ <span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">M</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m</span> ⇒
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_v">Eq_v</a></span> <span class="variable computation-variable">m'</span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span> <span class="constant computation-program"><a href="#theorem-ctx_member">ctx_member</a></span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="variable computation-variable">cr</span> <span class="variable computation-variable">m'</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M</span> <span class="variable meta-variable">N</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">m1</span> <span class="variable computation-variable">m2</span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">D1</span>] = <span class="constant computation-program"><a href="#theorem-reflR">reflR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] <span class="variable computation-variable">cr</span> <span class="variable computation-variable">m1</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">D2</span>] = <span class="constant computation-program"><a href="#theorem-reflR">reflR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">N</span>] <span class="variable computation-variable">cr</span> <span class="variable computation-variable">m2</span> <span class="keyword keyword-in">in</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_a">ae_a</a></span> <span class="variable meta-variable">D1</span> <span class="variable meta-variable">D2</span>]
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M</span>)] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">m'</span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">D</span>[…, <span class="variable lf-variable">b</span>.1, <span class="variable lf-variable">b</span>.2]] =
      <span class="constant computation-program"><a href="#theorem-reflR">reflR</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable meta-variable">M</span>] (<span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr</span>) <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_l">ae_l</a></span> (\x. \u. <span class="variable meta-variable">D</span>)];

<span class="keyword keyword-rec">rec</span> <span id="theorem-transV" class="constant computation-program">transV</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#p</span>.1] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#p</span>.1] →
        <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">L</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#p</span>.1] → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable parameter-variable">#p</span>.1 <span class="variable parameter-variable">#p</span>.1) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">n</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">l</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">m</span> <span class="keyword keyword-of">of</span>
  | <span class="constant computation-constructor"><a href="#comp-const-EqV_v">EqV_v</a></span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_v">EqV_v</a></span> = <span class="variable computation-variable">n</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_v">EqV_v</a></span> = <span class="variable computation-variable">l</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'</span> = <span class="variable computation-variable">cr</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr'</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr'</span> <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable lf-variable">b</span>.2]
  | <span class="constant computation-constructor"><a href="#comp-const-EqV_p">EqV_p</a></span> <span class="variable computation-variable">m'</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_p">EqV_p</a></span> <span class="variable computation-variable">n'</span> = <span class="variable computation-variable">n</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_p">EqV_p</a></span> <span class="variable computation-variable">l'</span> = <span class="variable computation-variable">l</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'</span> = <span class="variable computation-variable">cr</span>
    <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E</span>] = <span class="constant computation-program"><a href="#theorem-transV">transV</a></span> <span class="variable computation-variable">cr'</span> <span class="variable computation-variable">m'</span> <span class="variable computation-variable">n'</span> <span class="variable computation-variable">l'</span> <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">E</span>[…]];

<span class="keyword keyword-rec">rec</span> <span id="theorem-transR" class="constant computation-program">transR</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M'</span>] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N'</span>] →
        <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">L</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">L'</span>] →
          (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable meta-variable">M'</span> <span class="variable meta-variable">N'</span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable meta-variable">N'</span> <span class="variable meta-variable">L'</span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable meta-variable">M'</span> <span class="variable meta-variable">L'</span>) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">n</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">l</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">d1</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">d2</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">d1</span> <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#p</span>.2] ⇒ <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.2] = <span class="variable computation-variable">d2</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_v">Eq_v</a></span> <span class="variable computation-variable">m'</span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span>
      <span class="variable computation-variable">m'</span> :
        <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
          $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#r</span>]
          [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable parameter-variable">#q</span>.1[…]] = <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span>
    <span class="constant computation-program"><a href="#theorem-ctx_member">ctx_member</a></span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#r</span>] <span class="variable computation-variable">cr</span> <span class="variable computation-variable">m'</span>
  | [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_a">ae_a</a></span> <span class="variable meta-variable">D1</span> <span class="variable meta-variable">D2</span>] ⇒ <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_a">ae_a</a></span> <span class="variable meta-variable">F1</span> <span class="variable meta-variable">F2</span>] = <span class="variable computation-variable">d2</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">m1</span> <span class="variable computation-variable">m2</span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">n1</span> <span class="variable computation-variable">n2</span> = <span class="variable computation-variable">n</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">l1</span> <span class="variable computation-variable">l2</span> = <span class="variable computation-variable">l</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E1</span>] = <span class="constant computation-program"><a href="#theorem-transR">transR</a></span> <span class="variable computation-variable">cr</span> <span class="variable computation-variable">m1</span> <span class="variable computation-variable">n1</span> <span class="variable computation-variable">l1</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">D1</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">F1</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E2</span>] = <span class="constant computation-program"><a href="#theorem-transR">transR</a></span> <span class="variable computation-variable">cr</span> <span class="variable computation-variable">m2</span> <span class="variable computation-variable">n2</span> <span class="variable computation-variable">l2</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">D2</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">F2</span>] <span class="keyword keyword-in">in</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_a">ae_a</a></span> <span class="variable meta-variable">E1</span> <span class="variable meta-variable">E2</span>]
  | [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_l">ae_l</a></span> (\x. \u. <span class="variable meta-variable">D1</span>)] ⇒ <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_l">ae_l</a></span> (\x. \u. <span class="variable meta-variable">D2</span>)] = <span class="variable computation-variable">d2</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">m'</span> = <span class="variable computation-variable">m</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">n'</span> = <span class="variable computation-variable">n</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">l'</span> = <span class="variable computation-variable">l</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">F</span>[…, <span class="variable lf-variable">b</span>.1, <span class="variable lf-variable">b</span>.2]] =
      <span class="constant computation-program"><a href="#theorem-transR">transR</a></span> (<span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr</span>) <span class="variable computation-variable">m'</span> <span class="variable computation-variable">n'</span> <span class="variable computation-variable">l'</span>
        [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">D1</span>[…, <span class="variable lf-variable">b</span>.1, <span class="variable lf-variable">b</span>.2]]
        [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">D2</span>[…, <span class="variable lf-variable">b</span>.1, <span class="variable lf-variable">b</span>.2]] <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_l">ae_l</a></span> (\x. \u. <span class="variable meta-variable">F</span>)];

<span id="lf-type-deq" class="constant lf-type-constant">deq</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> → <span class="keyword keyword-type">type</span>.

<span id="lf-term-de_l" class="constant lf-term-constant">de_l</span> :
  ({x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>} <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span> → <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> (<span class="variable lf-variable">M</span> <span class="variable lf-variable">x</span>) (<span class="variable lf-variable">M'</span> <span class="variable lf-variable">x</span>)) →
    <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable lf-variable">M</span> <span class="variable lf-variable">x</span>)) (<span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable lf-variable">M'</span> <span class="variable lf-variable">x</span>)).

<span id="lf-term-de_a" class="constant lf-term-constant">de_a</span> : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">M1</span> <span class="variable lf-variable">N1</span> → <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">M2</span> <span class="variable lf-variable">N2</span> → <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable lf-variable">M1</span> <span class="variable lf-variable">M2</span>) (<span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable lf-variable">N1</span> <span class="variable lf-variable">N2</span>).

<span id="lf-term-de_r" class="constant lf-term-constant">de_r</span> : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">M</span> <span class="variable lf-variable">M</span>.

<span id="lf-term-de_t" class="constant lf-term-constant">de_t</span> : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">M</span> <span class="variable lf-variable">L</span> → <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">L</span> <span class="variable lf-variable">N</span> → <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">M</span> <span class="variable lf-variable">N</span>.

<span class="keyword keyword-schema">schema</span> <span id="schema-xdG" class="constant context-schema">xdG</span> = <span class="keyword keyword-block">block</span> (<span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, <span class="variable lf-variable">de_v</span> : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>);

<span class="keyword keyword-schema">schema</span> <span id="schema-daG" class="constant context-schema">daG</span> = <span class="keyword keyword-block">block</span> (<span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, <span class="variable lf-variable">ae_v</span> : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>, <span class="variable lf-variable">de_v</span> : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>);

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-Ctx_xdR" class="constant computation-inductive-type-constant">Ctx_xdR</span> : {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xdG">xdG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">ψ</span> ⊢ <span class="variable context-variable">φ</span>)} <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-Nil_xd" class="constant computation-constructor">Nil_xd</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [] [] $[ ⊢ ]
| <span id="comp-const-Cons_xd" class="constant computation-constructor">Cons_xd</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
      $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> ⊢ <span class="variable substitution-variable">$σ</span>[…], <span class="variable lf-variable">b</span>.1];

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-Ctx_adR" class="constant computation-inductive-type-constant">Ctx_adR</span> : {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xaG">xaG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xdG">xdG</a></span>} <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-Nil_ad" class="constant computation-constructor">Nil_ad</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_adR">Ctx_adR</a></span> [] []
| <span id="comp-const-Cons_ad" class="constant computation-constructor">Cons_ad</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_adR">Ctx_adR</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_adR">Ctx_adR</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
      [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)];</code></pre>

<div class="documentation">
	<p>
		Equality in addition to properties about equality, such as deterministic and existence. These
		properties are all encoded relationally, because we do not support functions in
		computation-level types. If we were to support functions in computation-level types, these
		proofs and some of these relations would go away.
	</p>
</div>

<pre><code><span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-EqV'" class="constant computation-inductive-type-constant">EqV'</span> :
  {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xdG">xdG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">ψ</span> ⊢ <span class="variable context-variable">φ</span>)} (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-EqV'_v" class="constant computation-constructor">EqV'_v</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV'">EqV'</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
    $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable substitution-variable">$σ</span>, <span class="variable lf-variable">b</span>.1] [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable lf-variable">x</span>]
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable lf-variable">b</span>.1]
| <span id="comp-const-EqV'_p" class="constant computation-constructor">EqV'_p</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV'">EqV'</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV'">EqV'</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
      $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> ⊢ <span class="variable substitution-variable">$σ</span>[…], <span class="variable lf-variable">b</span>.1] [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable parameter-variable">#p</span>[…]]
      [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable parameter-variable">#q</span>.1[…]];

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-Eq'" class="constant computation-inductive-type-constant">Eq'</span> :
  {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xdG">xdG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">ψ</span> ⊢ <span class="variable context-variable">φ</span>)} (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-Eq'_v" class="constant computation-constructor">Eq'_v</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV'">EqV'</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1]
| <span id="comp-const-Eq'_a" class="constant computation-constructor">Eq'_a</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M'</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N'</span>] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M</span> <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M'</span> <span class="variable meta-variable">N'</span>]
| <span id="comp-const-Eq'_l" class="constant computation-constructor">Eq'_l</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>] [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>)]
    $[<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable substitution-variable">$σ</span>[…], <span class="variable lf-variable">b</span>.1] [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable meta-variable">M</span>]
    [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">M'</span>[…, <span class="variable lf-variable">b</span>.1]] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">φ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M</span>)] [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M'</span>)];

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-Equal_xaG" class="constant computation-inductive-type-constant">Equal_xaG</span> : (<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xaG">xaG</a></span>) (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-Refl_xaG" class="constant computation-constructor">Refl_xaG</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Equal_xaG">Equal_xaG</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M</span>];

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-Equal_xG" class="constant computation-inductive-type-constant">Equal_xG</span> : (<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>) (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>) → <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-Refl_xG" class="constant computation-constructor">Refl_xG</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Equal_xG">Equal_xG</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">M</span>];

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-ExistsEq'" class="constant computation-inductive-type-constant">ExistsEq'</span> :
  {<span class="variable meta-variable">Γ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">φ</span> : <span class="constant context-schema"><a href="#schema-xdG">xdG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">φ</span> ⊢ <span class="variable context-variable">Γ</span>)} {<span class="variable meta-variable">L</span> : (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)} <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-ExistsEq'%2Fc" class="constant computation-constructor">ExistsEq'/c</span> :
  {<span class="variable meta-variable">L</span> : (<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)}
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">Ld</span>] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq'">ExistsEq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">Ld</span>]
| <span id="comp-const-ExistsEqV'" class="constant computation-constructor">ExistsEqV'</span> :
  {<span class="variable meta-variable">#p</span> : #(<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)}
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV'">EqV'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq'">ExistsEq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#q</span>.1];

<span class="keyword keyword-rec">rec</span> <span id="theorem-existsEqV'" class="constant computation-program">existsEqV'</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] →
    ({<span class="variable meta-variable">#p</span> : #(<span class="variable context-variable">φ</span> ⊢ <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>))}
       <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq'">ExistsEq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>.1]) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr_xd</span> ⇒ <span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">#p</span> ⇒ <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr_xd</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] = <span class="variable computation-variable">cr_xd</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>.1] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable lf-variable">b</span>.1] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xd">Cons_xd</a></span> <span class="variable computation-variable">cr'_xd</span> = <span class="variable computation-variable">cr_xd</span>
    <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr'_xd</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] = <span class="variable computation-variable">cr'_xd</span> <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEqV'">ExistsEqV'</a></span> [<span class="variable context-variable">Γ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable lf-variable">x</span>] <span class="constant computation-constructor"><a href="#comp-const-EqV'_v">EqV'_v</a></span>
  | [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable parameter-variable">#p</span>.1[…]] ⇒
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xd">Cons_xd</a></span> <span class="variable computation-variable">cr'_xd</span> = <span class="variable computation-variable">cr_xd</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEqV'">ExistsEqV'</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#r</span>] <span class="variable computation-variable">eq</span> = <span class="constant computation-program"><a href="#theorem-existsEqV'">existsEqV'</a></span> <span class="variable computation-variable">cr'_xd</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEqV'">ExistsEqV'</a></span> [<span class="variable context-variable">Γ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable parameter-variable">#r</span>[…]] (<span class="constant computation-constructor"><a href="#comp-const-EqV'_p">EqV'_p</a></span> <span class="variable computation-variable">eq</span>);

<span class="keyword keyword-rec">rec</span> <span id="theorem-existsEq'" class="constant computation-program">existsEq'</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] →
    ({<span class="variable meta-variable">Ld</span> : (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)} <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq'">ExistsEq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">Ld</span>]) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr_xd</span> ⇒ <span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">Ld</span> ⇒ <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr_xd</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] = <span class="variable computation-variable">cr_xd</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">Ld</span>] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>.1] ⇒ <span class="constant computation-program"><a href="#theorem-existsEqV'">existsEqV'</a></span> <span class="variable computation-variable">cr_xd</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>]
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M</span> <span class="variable meta-variable">N</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq'%2Fc">ExistsEq'/c</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L1</span>] <span class="variable computation-variable">eq1</span> = <span class="constant computation-program"><a href="#theorem-existsEq'">existsEq'</a></span> <span class="variable computation-variable">cr_xd</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">M</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq'%2Fc">ExistsEq'/c</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L2</span>] <span class="variable computation-variable">eq2</span> = <span class="constant computation-program"><a href="#theorem-existsEq'">existsEq'</a></span> <span class="variable computation-variable">cr_xd</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">N</span>] <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEq'%2Fc">ExistsEq'/c</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">L1</span> <span class="variable meta-variable">L2</span>] (<span class="constant computation-constructor"><a href="#comp-const-Eq'_a">Eq'_a</a></span> <span class="variable computation-variable">eq1</span> <span class="variable computation-variable">eq2</span>)
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M</span>)] ⇒
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq'%2Fc">ExistsEq'/c</a></span> [<span class="variable context-variable">Γ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable meta-variable">L</span>] <span class="variable computation-variable">eq</span> =
      <span class="constant computation-program"><a href="#theorem-existsEq'">existsEq'</a></span> (<span class="constant computation-constructor"><a href="#comp-const-Cons_xd">Cons_xd</a></span> <span class="variable computation-variable">cr_xd</span>)
        [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">M</span>[…, <span class="variable lf-variable">b</span>.1]] <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEq'%2Fc">ExistsEq'/c</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">L</span>)] (<span class="constant computation-constructor"><a href="#comp-const-Eq'_l">Eq'_l</a></span> <span class="variable computation-variable">eq</span>);

<span class="keyword keyword-inductive">inductive</span> <span id="ind-comp-type-ExistsEq" class="constant computation-inductive-type-constant">ExistsEq</span> :
  {<span class="variable meta-variable">Γ</span> : <span class="constant context-schema"><a href="#schema-xG">xG</a></span>} {<span class="variable meta-variable">ψ</span> : <span class="constant context-schema"><a href="#schema-xaG">xaG</a></span>} {<span class="variable meta-variable">$σ</span> : $(<span class="variable context-variable">ψ</span> ⊢ <span class="variable context-variable">Γ</span>)} {<span class="variable meta-variable">L</span> : (<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)} <span class="keyword keyword-ctype">ctype</span> =
| <span id="comp-const-ExistsEqV" class="constant computation-constructor">ExistsEqV</span> :
  {<span class="variable meta-variable">La</span> : (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)}
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq">ExistsEq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>]
| <span id="comp-const-ExistsEq%2Fc" class="constant computation-constructor">ExistsEq/c</span> :
  {<span class="variable meta-variable">La</span> : (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)}
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">La</span>] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq">ExistsEq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L</span>];

<span class="keyword keyword-rec">rec</span> <span id="theorem-existsEqV" class="constant computation-program">existsEqV</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
    ({<span class="variable meta-variable">#p</span> : #(<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)} <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq">ExistsEq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>]) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr_xa</span> ⇒ <span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">#p</span> ⇒ <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr_xa</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr_xa</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">Γ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable lf-variable">x</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'_xa</span> = <span class="variable computation-variable">cr_xa</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr'_xa</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr'_xa</span> <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEqV">ExistsEqV</a></span> [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable lf-variable">b</span>.1] <span class="constant computation-constructor"><a href="#comp-const-EqV_v">EqV_v</a></span>
  | [<span class="variable context-variable">Γ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable parameter-variable">#p</span>[…]] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr'_xa</span> = <span class="variable computation-variable">cr_xa</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEqV">ExistsEqV</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] <span class="variable computation-variable">eq</span> = <span class="constant computation-program"><a href="#theorem-existsEqV">existsEqV</a></span> <span class="variable computation-variable">cr'_xa</span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="variable computation-variable">eq</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] = <span class="variable computation-variable">eq</span> <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEqV">ExistsEqV</a></span> [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable parameter-variable">#q</span>.1[…]] (<span class="constant computation-constructor"><a href="#comp-const-EqV_p">EqV_p</a></span> <span class="variable computation-variable">eq</span>);

<span class="keyword keyword-rec">rec</span> <span id="theorem-existsEq" class="constant computation-program">existsEq</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
    ({<span class="variable meta-variable">L</span> : (<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>)} <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-ExistsEq">ExistsEq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L</span>]) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr_xa</span> ⇒ <span class="keyword keyword-mlam">mlam</span> <span class="variable meta-variable">L</span> ⇒ <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr_xa</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr_xa</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-case">case</span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L</span>] <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] ⇒ <span class="constant computation-program"><a href="#theorem-existsEqV">existsEqV</a></span> <span class="variable computation-variable">cr_xa</span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>]
  | [<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">M</span> <span class="variable meta-variable">N</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq%2Fc">ExistsEq/c</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">La1</span>] <span class="variable computation-variable">eq1</span> = <span class="constant computation-program"><a href="#theorem-existsEq">existsEq</a></span> <span class="variable computation-variable">cr_xa</span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq%2Fc">ExistsEq/c</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">La2</span>] <span class="variable computation-variable">eq2</span> = <span class="constant computation-program"><a href="#theorem-existsEq">existsEq</a></span> <span class="variable computation-variable">cr_xa</span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">N</span>] <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEq%2Fc">ExistsEq/c</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-app">app</a></span> <span class="variable meta-variable">La1</span> <span class="variable meta-variable">La2</span>] (<span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">eq1</span> <span class="variable computation-variable">eq2</span>)
  | [<span class="variable context-variable">Γ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">M</span>)] ⇒
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq%2Fc">ExistsEq/c</a></span> [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">La</span>[…, <span class="variable lf-variable">b</span>.1]] <span class="variable computation-variable">eq</span> =
      <span class="constant computation-program"><a href="#theorem-existsEq">existsEq</a></span> (<span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr_xa</span>) [<span class="variable context-variable">Γ</span>, <span class="variable lf-variable">x</span> : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span> ⊢ <span class="variable meta-variable">M</span>] <span class="keyword keyword-in">in</span>
    <span class="constant computation-constructor"><a href="#comp-const-ExistsEq%2Fc">ExistsEq/c</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-lam">lam</a></span> (\x. <span class="variable meta-variable">La</span>)] (<span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">eq</span>);

<span class="keyword keyword-rec">rec</span> <span id="theorem-det_eqV" class="constant computation-program">det_eqV</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#p</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#r</span>.1] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Equal_xaG">Equal_xaG</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#r</span>.1] =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">v</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">v'</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">v</span> <span class="keyword keyword-of">of</span>
  | <span class="constant computation-constructor"><a href="#comp-const-EqV_v">EqV_v</a></span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_v">EqV_v</a></span> = <span class="variable computation-variable">v'</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span>
  | <span class="constant computation-constructor"><a href="#comp-const-EqV_p">EqV_p</a></span> <span class="variable computation-variable">v</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV_p">EqV_p</a></span> <span class="variable computation-variable">v'</span> = <span class="variable computation-variable">v'</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eqV">det_eqV</a></span> <span class="variable computation-variable">v</span> <span class="variable computation-variable">v'</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span>;

<span class="keyword keyword-rec">rec</span> <span id="theorem-det_eq" class="constant computation-program">det_eq</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N'</span>] → <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Equal_xaG">Equal_xaG</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N'</span>] =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m'</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">m</span> <span class="keyword keyword-of">of</span>
  | <span class="constant computation-constructor"><a href="#comp-const-Eq_v">Eq_v</a></span> <span class="variable computation-variable">v</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_v">Eq_v</a></span> <span class="variable computation-variable">v'</span> = <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span> <span class="constant computation-program"><a href="#theorem-det_eqV">det_eqV</a></span> <span class="variable computation-variable">v</span> <span class="variable computation-variable">v'</span>
  | <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">m1</span> <span class="variable computation-variable">m2</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">n1</span> <span class="variable computation-variable">n2</span> = <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq">det_eq</a></span> <span class="variable computation-variable">m1</span> <span class="variable computation-variable">n1</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq">det_eq</a></span> <span class="variable computation-variable">m2</span> <span class="variable computation-variable">n2</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span>
  | <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">m</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">n</span> = <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq">det_eq</a></span> <span class="variable computation-variable">m</span> <span class="variable computation-variable">n</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span>;

<span class="keyword keyword-rec">rec</span> <span id="theorem-det_eqV'" class="constant computation-program">det_eqV'</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV'">EqV'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#q</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#p</span>.1] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV'">EqV'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#r</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#p</span>.1] → <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Equal_xG">Equal_xG</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#q</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#r</span>] =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">v</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">v'</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">v</span> <span class="keyword keyword-of">of</span>
  | <span class="constant computation-constructor"><a href="#comp-const-EqV'_v">EqV'_v</a></span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV'_v">EqV'_v</a></span> = <span class="variable computation-variable">v'</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span>
  | <span class="constant computation-constructor"><a href="#comp-const-EqV'_p">EqV'_p</a></span> <span class="variable computation-variable">v</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-EqV'_p">EqV'_p</a></span> <span class="variable computation-variable">v'</span> = <span class="variable computation-variable">v'</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eqV'">det_eqV'</a></span> <span class="variable computation-variable">v</span> <span class="variable computation-variable">v'</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span>;

<span class="keyword keyword-rec">rec</span> <span id="theorem-det_eq'" class="constant computation-program">det_eq'</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M'</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">N</span>] → <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Equal_xG">Equal_xG</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M'</span>] =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m'</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">m</span> <span class="keyword keyword-of">of</span>
  | <span class="constant computation-constructor"><a href="#comp-const-Eq'_v">Eq'_v</a></span> <span class="variable computation-variable">v</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_v">Eq'_v</a></span> <span class="variable computation-variable">v'</span> = <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span> <span class="constant computation-program"><a href="#theorem-det_eqV'">det_eqV'</a></span> <span class="variable computation-variable">v</span> <span class="variable computation-variable">v'</span>
  | <span class="constant computation-constructor"><a href="#comp-const-Eq'_a">Eq'_a</a></span> <span class="variable computation-variable">m1</span> <span class="variable computation-variable">m2</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_a">Eq'_a</a></span> <span class="variable computation-variable">n1</span> <span class="variable computation-variable">n2</span> = <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq'">det_eq'</a></span> <span class="variable computation-variable">m1</span> <span class="variable computation-variable">n1</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq'">det_eq'</a></span> <span class="variable computation-variable">m2</span> <span class="variable computation-variable">n2</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span>
  | <span class="constant computation-constructor"><a href="#comp-const-Eq'_l">Eq'_l</a></span> <span class="variable computation-variable">m</span> ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_l">Eq'_l</a></span> <span class="variable computation-variable">n</span> = <span class="variable computation-variable">m'</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq'">det_eq'</a></span> <span class="variable computation-variable">m</span> <span class="variable computation-variable">n</span> <span class="keyword keyword-in">in</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span>;

<span class="keyword keyword-rec">rec</span> <span id="theorem-ceq" class="constant computation-program">ceq</span> :
  <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] →
    <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xdR">Ctx_xdR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] →
      <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_adR">Ctx_adR</a></span> [<span class="variable context-variable">ψ</span>] [<span class="variable context-variable">φ</span>] →
        <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">Ma</span>] →
          <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq">Eq</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">N</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">Na</span>] →
            <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">M</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">Md</span>] →
              <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Eq'">Eq'</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">φ</span>] $[<span class="variable context-variable">φ</span> ⊢ <span class="variable substitution-variable">$T</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">N</span>] [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">Nd</span>] →
                (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable meta-variable">Md</span> <span class="variable meta-variable">Nd</span>) → (<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable meta-variable">Ma</span> <span class="variable meta-variable">Na</span>) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr_a</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr_d</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">cr_da</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">ma</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">na</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">md</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">nd</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">d</span> ⇒
  <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr_da</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_adR">Ctx_adR</a></span> [<span class="variable context-variable">ψ</span>] [<span class="variable context-variable">φ</span>] = <span class="variable computation-variable">cr_da</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-let">let</span> <span class="variable computation-variable">cr_a</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-Ctx_xaR">Ctx_xaR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] = <span class="variable computation-variable">cr_a</span> <span class="keyword keyword-in">in</span>
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">d</span> <span class="keyword keyword-of">of</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="variable parameter-variable">#p</span>.2] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq'">det_eq'</a></span> <span class="variable computation-variable">md</span> <span class="variable computation-variable">nd</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq">det_eq</a></span> <span class="variable computation-variable">ma</span> <span class="variable computation-variable">na</span>
    <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_v">Eq'_v</a></span> <span class="variable computation-variable">v'</span> = <span class="variable computation-variable">md</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_v">Eq_v</a></span> <span class="variable computation-variable">v</span> = <span class="variable computation-variable">ma</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="variable computation-variable">v</span> : <span class="constant computation-inductive-type-constant"><a href="#ind-comp-type-EqV">EqV</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">ψ</span>] $[<span class="variable context-variable">ψ</span> ⊢ <span class="variable substitution-variable">$σ</span>] [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#r</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable parameter-variable">#q</span>.1] = <span class="variable computation-variable">v</span> <span class="keyword keyword-in">in</span>
    <span class="constant computation-program"><a href="#theorem-ctx_member">ctx_member</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable parameter-variable">#r</span>] <span class="variable computation-variable">cr_a</span> <span class="variable computation-variable">v</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-de_r">de_r</a></span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xG">Refl_xG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq'">det_eq'</a></span> <span class="variable computation-variable">md</span> <span class="variable computation-variable">nd</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Refl_xaG">Refl_xaG</a></span> = <span class="constant computation-program"><a href="#theorem-det_eq">det_eq</a></span> <span class="variable computation-variable">ma</span> <span class="variable computation-variable">na</span>
    <span class="keyword keyword-in">in</span> <span class="constant computation-program"><a href="#theorem-reflR">reflR</a></span> [<span class="variable context-variable">Γ</span>] [<span class="variable context-variable">Γ</span> ⊢ _] <span class="variable computation-variable">cr_a</span> <span class="variable computation-variable">ma</span>
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-de_t">de_t</a></span> <span class="variable meta-variable">D1</span> <span class="variable meta-variable">D2</span>] ⇒ <span class="keyword keyword-let">let</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D1</span>] : (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable meta-variable">Md</span> <span class="variable meta-variable">Ld</span>) = [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D1</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D2</span>] : (<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable meta-variable">Ld</span> <span class="variable meta-variable">Nd</span>) = [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D2</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq'%2Fc">ExistsEq'/c</a></span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L</span>] <span class="variable computation-variable">ld</span> = <span class="constant computation-program"><a href="#theorem-existsEq'">existsEq'</a></span> <span class="variable computation-variable">cr_d</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">Ld</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-ExistsEq%2Fc">ExistsEq/c</a></span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">La</span>] <span class="variable computation-variable">la</span> = <span class="constant computation-program"><a href="#theorem-existsEq">existsEq</a></span> <span class="variable computation-variable">cr_a</span> [<span class="variable context-variable">Γ</span> ⊢ <span class="variable meta-variable">L</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E1</span>] = <span class="constant computation-program"><a href="#theorem-ceq">ceq</a></span> <span class="variable computation-variable">cr_a</span> <span class="variable computation-variable">cr_d</span> <span class="variable computation-variable">cr_da</span> <span class="variable computation-variable">ma</span> <span class="variable computation-variable">la</span> <span class="variable computation-variable">md</span> <span class="variable computation-variable">ld</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D1</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E2</span>] = <span class="constant computation-program"><a href="#theorem-ceq">ceq</a></span> <span class="variable computation-variable">cr_a</span> <span class="variable computation-variable">cr_d</span> <span class="variable computation-variable">cr_da</span> <span class="variable computation-variable">la</span> <span class="variable computation-variable">na</span> <span class="variable computation-variable">ld</span> <span class="variable computation-variable">nd</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D2</span>] <span class="keyword keyword-in">in</span>
    <span class="constant computation-program"><a href="#theorem-transR">transR</a></span> <span class="variable computation-variable">cr_a</span> <span class="variable computation-variable">ma</span> <span class="variable computation-variable">la</span> <span class="variable computation-variable">na</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E1</span>] [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E2</span>]
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-de_a">de_a</a></span> <span class="variable meta-variable">D1</span> <span class="variable meta-variable">D2</span>] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">ma1</span> <span class="variable computation-variable">ma2</span> = <span class="variable computation-variable">ma</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_a">Eq'_a</a></span> <span class="variable computation-variable">md1</span> <span class="variable computation-variable">md2</span> = <span class="variable computation-variable">md</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_a">Eq_a</a></span> <span class="variable computation-variable">na1</span> <span class="variable computation-variable">na2</span> = <span class="variable computation-variable">na</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_a">Eq'_a</a></span> <span class="variable computation-variable">nd1</span> <span class="variable computation-variable">nd2</span> = <span class="variable computation-variable">nd</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E1</span>] = <span class="constant computation-program"><a href="#theorem-ceq">ceq</a></span> <span class="variable computation-variable">cr_a</span> <span class="variable computation-variable">cr_d</span> <span class="variable computation-variable">cr_da</span> <span class="variable computation-variable">ma1</span> <span class="variable computation-variable">na1</span> <span class="variable computation-variable">md1</span> <span class="variable computation-variable">nd1</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D1</span>] <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span> ⊢ <span class="variable meta-variable">E2</span>] = <span class="constant computation-program"><a href="#theorem-ceq">ceq</a></span> <span class="variable computation-variable">cr_a</span> <span class="variable computation-variable">cr_d</span> <span class="variable computation-variable">cr_da</span> <span class="variable computation-variable">ma2</span> <span class="variable computation-variable">na2</span> <span class="variable computation-variable">md2</span> <span class="variable computation-variable">nd2</span> [<span class="variable context-variable">φ</span> ⊢ <span class="variable meta-variable">D2</span>] <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_a">ae_a</a></span> <span class="variable meta-variable">E1</span> <span class="variable meta-variable">E2</span>]
  | [<span class="variable context-variable">φ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-de_l">de_l</a></span> (\x. \u. <span class="variable meta-variable">D</span>)] ⇒ <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">ma1</span> = <span class="variable computation-variable">ma</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_l">Eq'_l</a></span> <span class="variable computation-variable">md1</span> = <span class="variable computation-variable">md</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq_l">Eq_l</a></span> <span class="variable computation-variable">na1</span> = <span class="variable computation-variable">na</span> <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> <span class="constant computation-constructor"><a href="#comp-const-Eq'_l">Eq'_l</a></span> <span class="variable computation-variable">nd1</span> = <span class="variable computation-variable">nd</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-let">let</span> [<span class="variable context-variable">ψ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-aeq">aeq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">E</span>[…, <span class="variable lf-variable">b</span>.1, <span class="variable lf-variable">b</span>.2]] =
      <span class="constant computation-program"><a href="#theorem-ceq">ceq</a></span> (<span class="constant computation-constructor"><a href="#comp-const-Cons_xa">Cons_xa</a></span> <span class="variable computation-variable">cr_a</span>) (<span class="constant computation-constructor"><a href="#comp-const-Cons_xd">Cons_xd</a></span> <span class="variable computation-variable">cr_d</span>) (<span class="constant computation-constructor"><a href="#comp-const-Cons_ad">Cons_ad</a></span> <span class="variable computation-variable">cr_da</span>) <span class="variable computation-variable">ma1</span> <span class="variable computation-variable">na1</span> <span class="variable computation-variable">md1</span> <span class="variable computation-variable">nd1</span>
        [<span class="variable context-variable">φ</span>, <span class="variable lf-variable">b</span> : <span class="keyword keyword-block">block</span> (x : <span class="constant lf-type-constant"><a href="#lf-type-tm">tm</a></span>, u : <span class="constant lf-type-constant"><a href="#lf-type-deq">deq</a></span> <span class="variable lf-variable">x</span> <span class="variable lf-variable">x</span>) ⊢ <span class="variable meta-variable">D</span>[…, <span class="variable lf-variable">b</span>.1, <span class="variable lf-variable">b</span>.2]] <span class="keyword keyword-in">in</span>
    [<span class="variable context-variable">ψ</span> ⊢ <span class="constant lf-term-constant"><a href="#lf-term-ae_l">ae_l</a></span> (\x. \u. <span class="variable meta-variable">E</span>)];</code></pre>
<!-- HTML_TAG_END --> <a class="btn btn-lg btn-primary mb-4" href="https://github.com/Beluga-lang/Beluga/blob/master/examples/literate_beluga/0Beginner/Untyped_Algorithmic_Equality_-_Context_Relation.bel" data-svelte-h="svelte-1aj4ljw">Download the code</a> <p class="text-muted clearfix" data-svelte-h="svelte-4w36mg">© Computation and Logic Group <a href="http://www.cs.mcgill.ca/"><img alt="McGill University Logo" class="float-end" src="/beluga-site/_app/immutable/assets/mcgill-logo.JvN3dR6R.png"></a> <br>
	Department of Computer Science, McGill University
	<br>
	3480 University Street, Montreal, Quebec, Canada, H3A 0E9</p></div> 
			
			<script>
				{
					__sveltekit_1i8eqz8 = {
						base: "/beluga-site",
						assets: "/beluga-site"
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("/beluga-site/_app/immutable/entry/start.g-2aDSD5.js"),
						import("/beluga-site/_app/immutable/entry/app.4pCwBffu.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 12],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
