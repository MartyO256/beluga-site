import{s as f,n as l}from"../chunks/scheduler.BRW4IjsR.js";import{S as m,i,s as y,H as v,x as r,k as h,d as p,f as d,o as _,g as c}from"../chunks/index.yRNBcVz4.js";const b=`<div class="documentation"><p>Types</p></div>

<pre><code><span id="lf-type-tp" class="constant lf-type-constant">tp</span> : <span class="keyword keyword-type">type</span>.
<span id="lf-term-bool" class="constant lf-term-constant">bool</span> : <span class="constant lf-type-constant"><a href="#lf-type-tp">tp</a></span>.
<span id="lf-term-nat" class="constant lf-term-constant">nat</span> : <span class="constant lf-type-constant"><a href="#lf-type-tp">tp</a></span>.</code></pre>

<div class="documentation"><p>Values</p></div>

<pre><code><span id="lf-type-value" class="constant lf-type-constant">value</span> : <span class="constant lf-type-constant"><a href="#lf-type-tp">tp</a></span> → <span class="keyword keyword-type">type</span>.

<span id="lf-term-v_zero" class="constant lf-term-constant">v_zero</span> : <span class="constant lf-type-constant"><a href="#lf-type-value">value</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span>.
<span id="lf-term-v_succ" class="constant lf-term-constant">v_succ</span> : <span class="constant lf-type-constant"><a href="#lf-type-value">value</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-value">value</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span>.
<span id="lf-term-v_true" class="constant lf-term-constant">v_true</span> : <span class="constant lf-type-constant"><a href="#lf-type-value">value</a></span> <span class="constant lf-term-constant"><a href="#lf-term-bool">bool</a></span>.
<span id="lf-term-v_false" class="constant lf-term-constant">v_false</span> : <span class="constant lf-type-constant"><a href="#lf-type-value">value</a></span> <span class="constant lf-term-constant"><a href="#lf-term-bool">bool</a></span>.</code></pre>

<div class="documentation"><p>Typed expressions</p></div>

<pre><code><span id="lf-type-term" class="constant lf-type-constant">term</span> : <span class="constant lf-type-constant"><a href="#lf-type-tp">tp</a></span> → <span class="keyword keyword-type">type</span>.

<span id="lf-term-true" class="constant lf-term-constant">true</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-bool">bool</a></span>.
<span id="lf-term-false" class="constant lf-term-constant">false</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-bool">bool</a></span>.
<span id="lf-term-switch" class="constant lf-term-constant">switch</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-bool">bool</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="variable lf-variable">T</span> → <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="variable lf-variable">T</span> → <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="variable lf-variable">T</span>.
<span id="lf-term-z" class="constant lf-term-constant">z</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span>.
<span id="lf-term-succ" class="constant lf-term-constant">succ</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span>.
<span id="lf-term-pred" class="constant lf-term-constant">pred</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span>.
<span id="lf-term-iszero" class="constant lf-term-constant">iszero</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-bool">bool</a></span>.

<span class="keyword keyword-rec">rec</span> <span id="theorem-eval" class="constant computation-program">eval</span> : ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="variable meta-variable">T</span>) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-value">value</a></span> <span class="variable meta-variable">T</span>) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">m</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">m</span> <span class="keyword keyword-of">of</span>
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-true">true</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_true">v_true</a></span>]
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-false">false</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_false">v_false</a></span>]
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-switch">switch</a></span> <span class="variable meta-variable">T1</span> <span class="variable meta-variable">T2</span> <span class="variable meta-variable">T3</span>] ⇒
    (<span class="keyword keyword-case">case</span> <span class="constant computation-program"><a href="#theorem-eval">eval</a></span> [ ⊢ <span class="variable meta-variable">T1</span>] <span class="keyword keyword-of">of</span>
     | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_true">v_true</a></span>] ⇒ <span class="constant computation-program"><a href="#theorem-eval">eval</a></span> [ ⊢ <span class="variable meta-variable">T2</span>]
     | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_false">v_false</a></span>] ⇒ <span class="constant computation-program"><a href="#theorem-eval">eval</a></span> [ ⊢ <span class="variable meta-variable">T3</span>])
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-z">z</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_zero">v_zero</a></span>]
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-succ">succ</a></span> <span class="variable meta-variable">N</span>] ⇒ <span class="keyword keyword-let">let</span> [ ⊢ <span class="variable meta-variable">V</span>] = <span class="constant computation-program"><a href="#theorem-eval">eval</a></span> [ ⊢ <span class="variable meta-variable">N</span>] <span class="keyword keyword-in">in</span> [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_succ">v_succ</a></span> <span class="variable meta-variable">V</span>]
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-pred">pred</a></span> <span class="variable meta-variable">N</span>] ⇒
    (<span class="keyword keyword-case">case</span> <span class="constant computation-program"><a href="#theorem-eval">eval</a></span> [ ⊢ <span class="variable meta-variable">N</span>] <span class="keyword keyword-of">of</span>
     | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_zero">v_zero</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_zero">v_zero</a></span>]
     | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-v_succ">v_succ</a></span> <span class="variable meta-variable">V</span>] ⇒ [ ⊢ <span class="variable meta-variable">V</span>]);

<span id="lf-type-list" class="constant lf-type-constant">list</span> : <span class="constant lf-type-constant"><a href="#lf-type-term">term</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nat">nat</a></span> → <span class="keyword keyword-type">type</span>.
<span id="lf-term-nil" class="constant lf-term-constant">nil</span> : <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="constant lf-term-constant"><a href="#lf-term-z">z</a></span>.
<span id="lf-term-cons" class="constant lf-term-constant">cons</span> : <span class="constant lf-type-constant"><a href="#lf-type-tp">tp</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="variable lf-variable">N</span> → <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-succ">succ</a></span> <span class="variable lf-variable">N</span>).

<span id="lf-type-exists_smaller_or_equal_list" class="constant lf-type-constant">exists_smaller_or_equal_list</span> : <span class="keyword keyword-type">type</span>.
<span id="lf-term-smaller_or_equal_list" class="constant lf-term-constant">smaller_or_equal_list</span> : <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="variable lf-variable">N</span> → <span class="constant lf-type-constant"><a href="#lf-type-exists_smaller_or_equal_list">exists_smaller_or_equal_list</a></span>.

<span id="lf-type-yes_or_no" class="constant lf-type-constant">yes_or_no</span> : <span class="keyword keyword-type">type</span>.
<span id="lf-term-yes" class="constant lf-term-constant">yes</span> : <span class="constant lf-type-constant"><a href="#lf-type-yes_or_no">yes_or_no</a></span>.
<span id="lf-term-no" class="constant lf-term-constant">no</span> : <span class="constant lf-type-constant"><a href="#lf-type-yes_or_no">yes_or_no</a></span>.

<span class="keyword keyword-rec">rec</span> <span id="theorem-filter" class="constant computation-program">filter</span> :
  ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="variable meta-variable">N</span>) →
    (( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-tp">tp</a></span>) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-yes_or_no">yes_or_no</a></span>)) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-exists_smaller_or_equal_list">exists_smaller_or_equal_list</a></span>) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">l</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">f</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">l</span> <span class="keyword keyword-of">of</span>
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-nil">nil</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-smaller_or_equal_list">smaller_or_equal_list</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nil">nil</a></span>]
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="variable meta-variable">H</span> <span class="variable meta-variable">T</span>] ⇒ (<span class="keyword keyword-let">let</span> [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-smaller_or_equal_list">smaller_or_equal_list</a></span> <span class="variable meta-variable">T'</span>] = <span class="constant computation-program"><a href="#theorem-filter">filter</a></span> [ ⊢ <span class="variable meta-variable">T</span>] <span class="variable computation-variable">f</span> <span class="keyword keyword-in">in</span>
    <span class="keyword keyword-case">case</span> <span class="variable computation-variable">f</span> [ ⊢ <span class="variable meta-variable">H</span>] <span class="keyword keyword-of">of</span>
    | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-yes">yes</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-smaller_or_equal_list">smaller_or_equal_list</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="variable meta-variable">H</span> <span class="variable meta-variable">T'</span>)]
    | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-no">no</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-smaller_or_equal_list">smaller_or_equal_list</a></span> <span class="variable meta-variable">T'</span>]);</code></pre>
`;function u(o){let s,n,t;return{c(){s=y(),n=new v(!1),t=r(),this.h()},l(a){h("svelte-1jlelns",document.head).forEach(p),s=d(a),n=_(a,!1),t=r(),this.h()},h(){document.title="typesterms2 Example",n.a=t},m(a,e){c(a,s,e),n.m(b,a,e),c(a,t,e)},p:l,i:l,o:l,d(a){a&&(p(s),p(t),n.d())}}}class T extends m{constructor(s){super(),i(this,s,null,u,f,{})}}export{T as component};
