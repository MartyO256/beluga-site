import{s as f,n as e}from"../chunks/scheduler.BRW4IjsR.js";import{S as i,i as m,s as y,H as d,x as c,k as b,d as p,f as v,o as h,g as o}from"../chunks/index.yRNBcVz4.js";const k=`<pre><code><span id="lf-type-bool" class="constant lf-type-constant">bool</span> : <span class="keyword keyword-type">type</span>.
<span id="lf-term-true" class="constant lf-term-constant">true</span> : <span class="constant lf-type-constant"><a href="#lf-type-bool">bool</a></span>.
<span id="lf-term-false" class="constant lf-term-constant">false</span> : <span class="constant lf-type-constant"><a href="#lf-type-bool">bool</a></span>.

<span id="lf-type-nat" class="constant lf-type-constant">nat</span> : <span class="keyword keyword-type">type</span>.
<span id="lf-term-z" class="constant lf-term-constant">z</span> : <span class="constant lf-type-constant"><a href="#lf-type-nat">nat</a></span>.
<span id="lf-term-succ" class="constant lf-term-constant">succ</span> : <span class="constant lf-type-constant"><a href="#lf-type-nat">nat</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-nat">nat</a></span>.

<span id="lf-type-list" class="constant lf-type-constant">list</span> : <span class="constant lf-type-constant"><a href="#lf-type-nat">nat</a></span> → <span class="keyword keyword-type">type</span>.
<span id="lf-term-nil" class="constant lf-term-constant">nil</span> : <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="constant lf-term-constant"><a href="#lf-term-z">z</a></span>.
<span id="lf-term-cons" class="constant lf-term-constant">cons</span> : <span class="constant lf-type-constant"><a href="#lf-type-bool">bool</a></span> → <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="variable lf-variable">N</span> → <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-succ">succ</a></span> <span class="variable lf-variable">N</span>).

<span class="keyword keyword-let">let</span> <span id="val-l1" class="constant computation-program">l1</span> = [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="constant lf-term-constant"><a href="#lf-term-true">true</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nil">nil</a></span>];

<span class="keyword keyword-let">let</span> <span id="val-l2" class="constant computation-program">l2</span> = [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="constant lf-term-constant"><a href="#lf-term-true">true</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="constant lf-term-constant"><a href="#lf-term-false">false</a></span> <span class="constant lf-term-constant"><a href="#lf-term-nil">nil</a></span>)];

<span class="keyword keyword-rec">rec</span> <span id="theorem-map" class="constant computation-program">map</span> : (( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-bool">bool</a></span>) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-bool">bool</a></span>)) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="variable meta-variable">N</span>) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="variable meta-variable">N</span>) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">f</span> ⇒ <span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">l</span> ⇒
  <span class="keyword keyword-case">case</span> <span class="variable computation-variable">l</span> <span class="keyword keyword-of">of</span>
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-nil">nil</a></span>] ⇒ [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-nil">nil</a></span>]
  | [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="variable meta-variable">H</span> <span class="variable meta-variable">T</span>] ⇒ <span class="keyword keyword-let">let</span> [ ⊢ <span class="variable meta-variable">H'</span>] = <span class="variable computation-variable">f</span> [ ⊢ <span class="variable meta-variable">H</span>] <span class="keyword keyword-in">in</span> <span class="keyword keyword-let">let</span> [ ⊢ <span class="variable meta-variable">T'</span>] = <span class="constant computation-program"><a href="#theorem-map">map</a></span> <span class="variable computation-variable">f</span> [ ⊢ <span class="variable meta-variable">T</span>] <span class="keyword keyword-in">in</span>
    [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="variable meta-variable">H'</span> <span class="variable meta-variable">T'</span>];

<span class="keyword keyword-rec">rec</span> <span id="theorem-head" class="constant computation-program">head</span> : ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-succ">succ</a></span> <span class="variable meta-variable">N</span>)) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-bool">bool</a></span>) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">l</span> ⇒ <span class="keyword keyword-let">let</span> [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> <span class="variable meta-variable">H</span> _] = <span class="variable computation-variable">l</span> <span class="keyword keyword-in">in</span> [ ⊢ <span class="variable meta-variable">H</span>];

<span class="keyword keyword-rec">rec</span> <span id="theorem-tail" class="constant computation-program">tail</span> : ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> (<span class="constant lf-term-constant"><a href="#lf-term-succ">succ</a></span> <span class="variable meta-variable">N</span>)) → ( ⊢ <span class="constant lf-type-constant"><a href="#lf-type-list">list</a></span> <span class="variable meta-variable">N</span>) =
<span class="keyword keyword-fn">fn</span> <span class="variable computation-variable">l</span> ⇒ <span class="keyword keyword-let">let</span> [ ⊢ <span class="constant lf-term-constant"><a href="#lf-term-cons">cons</a></span> _ <span class="variable meta-variable">T</span>] = <span class="variable computation-variable">l</span> <span class="keyword keyword-in">in</span> [ ⊢ <span class="variable meta-variable">T</span>];</code></pre>
`;function w(r){let s,n,t;return{c(){s=y(),n=new d(!1),t=c(),this.h()},l(a){b("svelte-ozfcsq",document.head).forEach(p),s=v(a),n=h(a,!1),t=c(),this.h()},h(){document.title="dtlist Example",n.a=t},m(a,l){o(a,s,l),n.m(k,a,l),o(a,t,l)},p:e,i:e,o:e,d(a){a&&(p(s),p(t),n.d())}}}class g extends i{constructor(s){super(),m(this,s,null,w,f,{})}}export{g as component};
